@startuml Job Structure
    class JobId {
        +id: String
    }

    abstract class Job {
        +id: JobId
    }

    class UnsortedJob {
        +data: List[Integer]
    }

    class SortedJob {
        +data: List[Integer]
    }

    class CombinationJob {
        +left_sub_job: JobId
        +middle_sub_job: JobId
        +right_sub_job: JobId
    }

    Job <|.. UnsortedJob
    Job <|.. CombinationJob
    Job <|.. SortedJob

    Job *-- JobId : id

    CombinationJob *-- JobId : left sub job
    CombinationJob *-- JobId : middle sub
    CombinationJob *-- JobId : right sub
@enduml

@startuml Design Overview
autoactivate on
autonumber "<b>[00]"
Actor User
Boundary WebApp
Database "Job Store" AS JobStore
Control "Unsorted Event Queue" AS UnsortedEventQueue
Control "Quicksort Service" AS QuicksortService
Control "Sorted Event Queue" AS SortedEventQueue
Control "Combiner Service" AS CombinerService

par Submitting a Job
    User -> WebApp : Submit Number String
        WebApp -> JobStore : Register a new job
        return
    return
else Monitoring Unsorted Jobs
    loop Forever
        JobStore -> JobStore : Check for new jobs
            alt New jobs found
                JobStore -> UnsortedEventQueue : Add new jobs to Event Queue(JobId)
                return
            end
        return
    end
else Processing Jobs
    loop Forever
        QuicksortService -> UnsortedEventQueue : Get Job from Event Queue
        return
        QuicksortService -> QuicksortService : Process job from Event Queue
            alt Job larger than threshold size
                QuicksortService -> QuicksortService : Split job into smaller jobs
                note right: The job will be split into 3 parts for QuickSort; left, middle, right
                    QuicksortService -> JobStore : Register Sub Jobs
                    return
                return
            else Job smaller than (or equal to) threshold size
                QuicksortService -> QuicksortService : Sort job
                return
                QuicksortService -> JobStore : Add completed job
                return
            end
        return
    end
else Monitoring Sorted Jobs
    loop Forever
        JobStore -> JobStore : Check for completed jobs
            alt Completed jobs found
                JobStore -> JobStore : Mark jobs as completed
                return
                JobStore -> SortedEventQueue : Add completed jobs to Sorted Event Queue
                return
            end
        return
    end
else Recombine Jobs
    loop Forever
        CombinerService -> SortedEventQueue : Get Combining Job from Sorted Event Queue
        return
        CombinerService -> JobStore : Get parts for recombination
        return
        alt Job is Fully recombined
            CombinerService -> JobStore : Store Completed Job
            return
        else Job is not Fully recombined
            CombinerService -> CombinerService: Look for other pieces
                alt Parts found for recombination
                    CombinerService -> CombinerService: Combine parts
                        CombinerService -> SortedEventQueue : Add recombined job to Sorted Event Queue
                        return
                    return
                else Could not find parts for recombination
                    CombinerService -> SortedEventQueue : Add job back to Sorted Event Queue
                    return
                end
            return
        end
    end
else View Results
    User -> WebApp : Request Results
        WebApp -> JobStore : Get Results
        return
        WebApp -> WebApp : Display Results
        return
    return
end

@enduml